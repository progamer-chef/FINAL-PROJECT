<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3JS Main Panel with Doors and Click Rotation (Card Flip with Separate Text)</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene, camera, renderer;
      let mainPanel, mainPanelBorder;
      let cornerLines = [];
      let doorMesh;   // Door on the bottom-left connecting line.
      let doorMesh2;  // Door on the bottom-right connecting line.
      
      // Global variables for rotation animation.
      let targetRotationY = 0;
      let isRotating = false;
      
      // We'll store our text texture so we can update it on resize if needed.
      let textTexture;
      
      init();
      animate();
      
      // Utility function to create (or recreate) the text texture.
      function createTextTexture() {
        const canvas = document.createElement('canvas');
        // Set a high resolution for better quality.
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        // Fill background white.
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // Draw text.
        ctx.fillStyle = "#000000";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const text = "T-Shirt Design for アオちゃん\n\n" +
                     "アオちゃん was my coworker for a café I worked at. She's an amazing pastry chef,\n" +
                     "always fashionable and one of the nicest people I met in Japan.\n\n" +
                     "In the top right, the blue apron was our standard uniform. In the bottom left is my\n" +
                     "attempt at making fake Japanese fashion. The shirt says IM COOL YO.\n\n" +
                     "The bottom right features an Ao-Chan in a Tiger suit – an inside joke about cougars\n" +
                     "and big cats.\n\n" +
                     "The sunflowers come from the kanji for Ao-Chan's uncontracted name Aoi.\n\n" +
                     "My hand-drawn characters say *Aoi's T-shirt, do not steal* (meaning my older sister is\n" +
                     "totally rad).";
        const lines = text.split('\n');
        const lineHeight = 50;
        // Draw each line (you can adjust positioning as needed)
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], canvas.width / 2, canvas.height / 2 - (lines.length / 2 - i) * lineHeight);
        }
        return new THREE.CanvasTexture(canvas);
      }
      
      function init() {
        // Create the scene with a white background.
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        
        // Create a perspective camera.
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 5;
        
        // Set up the renderer.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Load the front texture.
        const textureLoader = new THREE.TextureLoader();
        const frontTexture = textureLoader.load('aochan.jpg');
        
        // Create the main panel material using the front texture.
        const panelMaterial = new THREE.MeshBasicMaterial({
          map: frontTexture,
          side: THREE.DoubleSide
        });
        
        // Create the main panel with an empty geometry (it will be updated in updateScene).
        mainPanel = new THREE.Mesh(new THREE.BufferGeometry(), panelMaterial);
        scene.add(mainPanel);
        
        // Create four black connecting lines.
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        for (let i = 0; i < 4; i++) {
          const lineGeom = new THREE.BufferGeometry();
          lineGeom.setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
          const line = new THREE.Line(lineGeom, lineMaterial);
          scene.add(line);
          cornerLines.push(line);
        }
        
        // Create the text texture for the card's back.
        textTexture = createTextTexture();
        
        // Set up raycaster and mouse vector for click interactions.
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
          // Convert mouse position to normalized device coordinates (-1 to +1).
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(mainPanel);
          if (intersects.length > 0) {
            console.log("Main panel clicked!");
            targetRotationY = mainPanel.rotation.y + Math.PI;
            isRotating = true;
          }
        }
        window.addEventListener("click", onMouseClick, false);
        
        // Build the scene geometry.
        updateScene();
        window.addEventListener('resize', onWindowResize, false);
      }
      
      function updateScene() {
        // --- Compute Viewport and Main Panel Dimensions ---
        const distance = camera.position.z;
        const vFOV = THREE.Math.degToRad(camera.fov);
        const viewHeight = 2 * distance * Math.tan(vFOV / 2);
        const viewWidth = viewHeight * camera.aspect;
        
        const halfWidth = viewWidth / 2;
        const halfHeight = viewHeight / 2;
        const vpLeft = -halfWidth;
        const vpRight = halfWidth;
        const vpTop = halfHeight;
        const vpBottom = -halfHeight;
        
        // Define main panel boundaries (80% of viewport).
        const mainLeft = -0.4 * viewWidth;
        const mainRight = 0.4 * viewWidth;
        const mainTop = 0.4 * viewHeight;
        const mainBottom = -0.4 * viewHeight;
        
        // --- Update Main Panel Geometry ---
        const mainGeom = new THREE.BufferGeometry();
        const mainVertices = new Float32Array([
          mainLeft,  mainTop,    0,
          mainRight, mainTop,    0,
          mainRight, mainBottom, 0,
          mainLeft,  mainBottom, 0
        ]);
        mainGeom.setAttribute('position', new THREE.BufferAttribute(mainVertices, 3));
        const uvs = new Float32Array([
          0, 1,
          1, 1,
          1, 0,
          0, 0
        ]);
        mainGeom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        mainGeom.setIndex([0, 1, 2, 2, 3, 0]);
        mainGeom.computeVertexNormals();
        mainPanel.geometry.dispose();
        mainPanel.geometry = mainGeom;
        
        // --- Update Main Panel Border ---
        if (mainPanelBorder) {
          scene.remove(mainPanelBorder);
          mainPanelBorder.geometry.dispose();
        }
        mainPanelBorder = new THREE.LineSegments(
          new THREE.EdgesGeometry(mainPanel.geometry),
          new THREE.LineBasicMaterial({ color: 0x000000 })
        );
        scene.add(mainPanelBorder);
        
        // --- Update the Corner Connecting Lines ---
        const pairs = [
          { window: new THREE.Vector3(vpLeft, vpTop, 0), panel: new THREE.Vector3(mainLeft, mainTop, 0) },
          { window: new THREE.Vector3(vpRight, vpTop, 0), panel: new THREE.Vector3(mainRight, mainTop, 0) },
          { window: new THREE.Vector3(vpRight, vpBottom, 0), panel: new THREE.Vector3(mainRight, mainBottom, 0) },
          { window: new THREE.Vector3(vpLeft, vpBottom, 0), panel: new THREE.Vector3(mainLeft, mainBottom, 0) }
        ];
        for (let i = 0; i < 4; i++) {
          const pts = [pairs[i].window, pairs[i].panel];
          const lineGeom = new THREE.BufferGeometry().setFromPoints(pts);
          cornerLines[i].geometry.dispose();
          cornerLines[i].geometry = lineGeom;
        }
        
        // --- Create/Update Door on the Bottom-Left and Bottom-Right Lines (unchanged) ---
        // [Your door code remains here...]
        // (For brevity, the door code remains the same as in your original implementation.)
        // --- Create/Update Door on the Bottom-Left Line ---
        const A = new THREE.Vector3(vpLeft, vpBottom, 0);
        const B = new THREE.Vector3(mainLeft, mainBottom, 0);
        const dir = new THREE.Vector3().subVectors(B, A);
        const lineLength = dir.length();
        const doorLength = 0.3 * lineLength;
        const doorDir = dir.clone().normalize();
        const M = new THREE.Vector3().addVectors(A, B).multiplyScalar(0.5);
        const doorBottomLeft = M.clone().addScaledVector(doorDir, -doorLength / 2);
        const doorBottomRight = M.clone().addScaledVector(doorDir, doorLength / 2);
        const vertical = new THREE.Vector3(0, 1, 0);
        const doorHeight = 0.1 * viewHeight;
        const doorTopLeft = doorBottomLeft.clone().addScaledVector(vertical, doorHeight);
        const doorTopRight = doorBottomRight.clone().addScaledVector(vertical, doorHeight);
        const doorVertices = new Float32Array([
          doorBottomLeft.x, doorBottomLeft.y, doorBottomLeft.z,
          doorBottomRight.x, doorBottomRight.y, doorBottomRight.z,
          doorTopRight.x, doorTopRight.y, doorTopRight.z,
          doorTopLeft.x, doorTopLeft.y, doorTopLeft.z
        ]);
        const doorGeom = new THREE.BufferGeometry();
        doorGeom.setAttribute('position', new THREE.BufferAttribute(doorVertices, 3));
        doorGeom.setIndex([0, 1, 2, 2, 3, 0]);
        doorGeom.computeVertexNormals();
        if (doorMesh) {
          scene.remove(doorMesh);
          doorMesh.geometry.dispose();
        }
        const doorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        doorMesh = new THREE.Mesh(doorGeom, doorMaterial);
        scene.add(doorMesh);
        
        // --- Create/Update Door on the Bottom-Right Line ---
        const A2 = new THREE.Vector3(vpRight, vpBottom, 0);
        const B2 = new THREE.Vector3(mainRight, mainBottom, 0);
        const dir2 = new THREE.Vector3().subVectors(B2, A2);
        const lineLength2 = dir2.length();
        const doorLength2 = 0.3 * lineLength2;
        const doorDir2 = dir2.clone().normalize();
        const M2 = new THREE.Vector3().addVectors(A2, B2).multiplyScalar(0.5);
        const doorBottomLeft2 = M2.clone().addScaledVector(doorDir2, -doorLength2 / 2);
        const doorBottomRight2 = M2.clone().addScaledVector(doorDir2, doorLength2 / 2);
        const doorTopLeft2 = doorBottomLeft2.clone().addScaledVector(vertical, doorHeight);
        const doorTopRight2 = doorBottomRight2.clone().addScaledVector(vertical, doorHeight);
        const doorVertices2 = new Float32Array([
          doorBottomLeft2.x, doorBottomLeft2.y, doorBottomLeft2.z,
          doorBottomRight2.x, doorBottomRight2.y, doorBottomRight2.z,
          doorTopRight2.x, doorTopRight2.y, doorTopRight2.z,
          doorTopLeft2.x, doorTopLeft2.y, doorTopLeft2.z
        ]);
        const doorGeom2 = new THREE.BufferGeometry();
        doorGeom2.setAttribute('position', new THREE.BufferAttribute(doorVertices2, 3));
        doorGeom2.setIndex([0, 1, 2, 2, 3, 0]);
        doorGeom2.computeVertexNormals();
        if (doorMesh2) {
          scene.remove(doorMesh2);
          doorMesh2.geometry.dispose();
        }
        const doorMaterial2 = new THREE.MeshBasicMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
        doorMesh2 = new THREE.Mesh(doorGeom2, doorMaterial2);
        scene.add(doorMesh2);
        
        // --- Create/Update the Back Text Mesh as a Child of mainPanel ---
        // Use the card dimensions:
        const cardWidth = mainRight - mainLeft;
        const cardHeight = mainTop - mainBottom;
        if (!mainPanel.userData.textMesh) {
          const textGeometry = new THREE.PlaneGeometry(cardWidth, cardHeight);
          const textMaterial = new THREE.MeshBasicMaterial({
            map: textTexture,
            transparent: true,
            side: THREE.DoubleSide
          });
          const textMesh = new THREE.Mesh(textGeometry, textMaterial);
          // Position the textMesh so it sits on the back face of the card.
          // In mainPanel's local space, the card lies in the XY-plane (z = 0).
          // We offset the textMesh slightly in the -z direction.
          textMesh.position.set(0, 0, -0.01);
          // Rotate the textMesh by 180° around the Y-axis so it appears upright when the card is flipped.
          textMesh.rotation.y = Math.PI;
          mainPanel.add(textMesh);
          mainPanel.userData.textMesh = textMesh;
        } else {
          // Update the geometry to match new card dimensions.
          mainPanel.userData.textMesh.geometry.dispose();
          mainPanel.userData.textMesh.geometry = new THREE.PlaneGeometry(cardWidth, cardHeight);
        }
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Optionally, update the text texture for better resolution:
        textTexture = createTextTexture();
        if (mainPanel.userData.textMesh) {
          mainPanel.userData.textMesh.material.map = textTexture;
          mainPanel.userData.textMesh.material.needsUpdate = true;
        }
        updateScene();
      }
      
      function animate() {
        requestAnimationFrame(animate);
        
        // Animate the main panel's rotation if needed.
        if (isRotating) {
          const delta = targetRotationY - mainPanel.rotation.y;
          if (Math.abs(delta) < 0.01) {
            mainPanel.rotation.y = targetRotationY;
            isRotating = false;
          } else {
            mainPanel.rotation.y += delta * 0.1;
          }
        }
        
        // Update text mesh visibility:
        // Calculate effective rotation in [0, 2π)
        let effectiveRotation = mainPanel.rotation.y % (2 * Math.PI);
        if (effectiveRotation < 0) effectiveRotation += 2 * Math.PI;
        // Show the text mesh when the card is mostly flipped (e.g. past 90°)
        if (mainPanel.userData.textMesh) {
          mainPanel.userData.textMesh.visible = (effectiveRotation >= Math.PI / 2);
        }
        
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
