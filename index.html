<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3JS Main Panel with Dynamic Text Backside</title>
    <style>
      body { 
        margin: 0; 
        overflow: hidden; 
        font-family: Arial, sans-serif;
      }
      canvas { 
        display: block; 
      }
      #textContainer {
        position: absolute;
        background-color: #fff;
        font-family: monospace;
        width: 80%;
        height: 80%;
        top: 10%;
        left: 10%;
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        cursor: pointer; /* Add cursor to indicate it's clickable */
        z-index: 100; /* Ensure text appears on top */
      }
    </style>
  </head>
  <body>
    <!-- Text container div -->
    <div id="textContainer">
      <div style="padding: 20px; max-width: 80%;">
        <h2>T-Shirt Design for アオちゃん</h2>
        <p>アオちゃん was my coworker for a café I worked at. She's an amazing pastry chef, always fashionable and one of the nicest people I met in Japan.</p>
        <p>In the top right, the blue apron was our standard uniform. In the bottom left is my attempt at making fake Japanese fashion. The shirt says IM COOL YO.</p>
        <p>The bottom right features an Ao-Chan in a Tiger suit – an inside joke about cougars and big cats.</p>
        <p>The sunflowers come from the kanji for Ao-Chan's uncontracted name Aoi.</p>
        <p>My hand-drawn characters say <em>Aoi's T-shirt, do not steal</em> (meaning my older sister is totally rad).</p>
      </div>
    </div>

    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene, camera, renderer;
      let mainPanel, mainPanelBorder;
      let cornerLines = [];
      let doorMesh;   // Door on the bottom-left connecting line.
      let doorMesh2;  // Door on the bottom-right connecting line.
      
      // Track if we're viewing the panel or text
      let isViewingPanel = true;
      
      // Text container element
      const textContainer = document.getElementById('textContainer');
      
      init();
      animate();
      
      function init() {
        // Create the scene with a white background.
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        
        // Create a perspective camera.
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 5;
        
        // Set up the renderer.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Load the front texture.
        const textureLoader = new THREE.TextureLoader();
        const frontTexture = textureLoader.load('aochan.jpg');
        
        // Create the main panel material using the front texture.
        const panelMaterial = new THREE.MeshBasicMaterial({
          map: frontTexture,
          side: THREE.DoubleSide
        });
        
        // Create the main panel with an empty geometry (it will be updated in updateScene).
        mainPanel = new THREE.Mesh(new THREE.BufferGeometry(), panelMaterial);
        scene.add(mainPanel);
        
        // Initialize corner lines array but don't create geometry yet
        cornerLines = [null, null, null, null];
        
        // Set up raycaster and mouse vector for click interactions.
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
          // Only process panel clicks if we're in panel view mode
          if (isViewingPanel) {
            // Convert mouse position to normalized device coordinates (-1 to +1).
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects([mainPanel, mainPanelBorder]);
            if (intersects.length > 0) {
              console.log("Main panel clicked!");
              
              // Hide panel and all related elements
              mainPanel.visible = false;
              cornerLines.forEach(line => { if (line) line.visible = false; });
              if (doorMesh) doorMesh.visible = false;
              if (doorMesh2) doorMesh2.visible = false;
              
              // Position text container where the panel was
              textContainer.style.display = 'flex';
              
              // Update state
              isViewingPanel = false;
              
              // Force a render to update immediately
              renderer.render(scene, camera);
            }
          }
        }
        window.addEventListener("click", onMouseClick, false);
        
        // Add click handler for text container to show panel again
        textContainer.addEventListener("click", function(event) {
          console.log("Text container clicked!");
          // Prevent the event from bubbling up
          event.stopPropagation();
          
          // Force the panel to reappear regardless of state
          mainPanel.visible = true;
          cornerLines.forEach(line => { if (line) line.visible = true; });
          if (doorMesh) doorMesh.visible = true;
          if (doorMesh2) doorMesh2.visible = true;
          
          // Hide the text
          textContainer.style.display = 'none';
          
          // Update state
          isViewingPanel = true;
          
          // Force a render to update immediately
          renderer.render(scene, camera);
        });
        
        // Build the scene geometry.
        updateScene();
        window.addEventListener('resize', onWindowResize, false);
      }
      
      function updateScene() {
        // If we're in text view mode, don't do any updates
        if (!isViewingPanel) {
          return;
        }
        
        // --- Compute Viewport and Main Panel Dimensions ---
        const distance = camera.position.z;
        const vFOV = THREE.Math.degToRad(camera.fov);
        const viewHeight = 2 * distance * Math.tan(vFOV / 2);
        const viewWidth = viewHeight * camera.aspect;
        
        const halfWidth = viewWidth / 2;
        const halfHeight = viewHeight / 2;
        const vpLeft = -halfWidth;
        const vpRight = halfWidth;
        const vpTop = halfHeight;
        const vpBottom = -halfHeight;
        
        // Define main panel boundaries (80% of viewport).
        const mainLeft = -0.4 * viewWidth;
        const mainRight = 0.4 * viewWidth;
        const mainTop = 0.4 * viewHeight;
        const mainBottom = -0.4 * viewHeight;
        
        // --- Update Main Panel Geometry ---
        const mainGeom = new THREE.BufferGeometry();
        const mainVertices = new Float32Array([
          mainLeft,  mainTop,    0,
          mainRight, mainTop,    0,
          mainRight, mainBottom, 0,
          mainLeft,  mainBottom, 0
        ]);
        mainGeom.setAttribute('position', new THREE.BufferAttribute(mainVertices, 3));
        const uvs = new Float32Array([
          0, 1,
          1, 1,
          1, 0,
          0, 0
        ]);
        mainGeom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        mainGeom.setIndex([0, 1, 2, 2, 3, 0]);
        mainGeom.computeVertexNormals();
        
        // Dispose of old geometry before replacing
        if (mainPanel.geometry) {
          mainPanel.geometry.dispose();
        }
        mainPanel.geometry = mainGeom;
        
        // --- Update Main Panel Border ---
        if (mainPanelBorder) {
          mainPanel.remove(mainPanelBorder);
          mainPanelBorder.geometry.dispose();
        }
        mainPanelBorder = new THREE.LineSegments(
          new THREE.EdgesGeometry(mainPanel.geometry),
          new THREE.LineBasicMaterial({ color: 0x000000 })
        );
        // Add border to panel so it moves with it
        mainPanel.add(mainPanelBorder);
        
        // --- Update the Corner Connecting Lines ---
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const pairs = [
          { window: new THREE.Vector3(vpLeft, vpTop, 0), panel: new THREE.Vector3(mainLeft, mainTop, 0) },
          { window: new THREE.Vector3(vpRight, vpTop, 0), panel: new THREE.Vector3(mainRight, mainTop, 0) },
          { window: new THREE.Vector3(vpRight, vpBottom, 0), panel: new THREE.Vector3(mainRight, mainBottom, 0) },
          { window: new THREE.Vector3(vpLeft, vpBottom, 0), panel: new THREE.Vector3(mainLeft, mainBottom, 0) }
        ];
        
        // Handle each corner line
        for (let i = 0; i < 4; i++) {
          const pts = [pairs[i].window, pairs[i].panel];
          const lineGeom = new THREE.BufferGeometry().setFromPoints(pts);
          
          // If the line already exists, update its geometry
          if (cornerLines[i]) {
            scene.remove(cornerLines[i]);
            cornerLines[i].geometry.dispose();
          }
          
          // Create a new line
          cornerLines[i] = new THREE.Line(lineGeom, lineMaterial);
          scene.add(cornerLines[i]);
        }
        
        // --- Create/Update Door on the Bottom-Left Line ---
        const A = new THREE.Vector3(vpLeft, vpBottom, 0);
        const B = new THREE.Vector3(mainLeft, mainBottom, 0);
        const dir = new THREE.Vector3().subVectors(B, A);
        const lineLength = dir.length();
        const doorLength = 0.3 * lineLength;
        const doorDir = dir.clone().normalize();
        const M = new THREE.Vector3().addVectors(A, B).multiplyScalar(0.5);
        const doorBottomLeft = M.clone().addScaledVector(doorDir, -doorLength / 2);
        const doorBottomRight = M.clone().addScaledVector(doorDir, doorLength / 2);
        const vertical = new THREE.Vector3(0, 1, 0);
        const doorHeight = 0.1 * viewHeight;
        const doorTopLeft = doorBottomLeft.clone().addScaledVector(vertical, doorHeight);
        const doorTopRight = doorBottomRight.clone().addScaledVector(vertical, doorHeight);
        const doorVertices = new Float32Array([
          doorBottomLeft.x, doorBottomLeft.y, doorBottomLeft.z,
          doorBottomRight.x, doorBottomRight.y, doorBottomRight.z,
          doorTopRight.x, doorTopRight.y, doorTopRight.z,
          doorTopLeft.x, doorTopLeft.y, doorTopLeft.z
        ]);
        const doorGeom = new THREE.BufferGeometry();
        doorGeom.setAttribute('position', new THREE.BufferAttribute(doorVertices, 3));
        doorGeom.setIndex([0, 1, 2, 2, 3, 0]);
        doorGeom.computeVertexNormals();
        
        // Clean up existing door mesh
        if (doorMesh) {
          scene.remove(doorMesh);
          doorMesh.geometry.dispose();
          doorMesh.material.dispose();
        }
        
        const doorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        doorMesh = new THREE.Mesh(doorGeom, doorMaterial);
        scene.add(doorMesh);
        
        // --- Create/Update Door on the Bottom-Right Line ---
        const A2 = new THREE.Vector3(vpRight, vpBottom, 0);
        const B2 = new THREE.Vector3(mainRight, mainBottom, 0);
        const dir2 = new THREE.Vector3().subVectors(B2, A2);
        const lineLength2 = dir2.length();
        const doorLength2 = 0.3 * lineLength2;
        const doorDir2 = dir2.clone().normalize();
        const M2 = new THREE.Vector3().addVectors(A2, B2).multiplyScalar(0.5);
        const doorBottomLeft2 = M2.clone().addScaledVector(doorDir2, -doorLength2 / 2);
        const doorBottomRight2 = M2.clone().addScaledVector(doorDir2, doorLength2 / 2);
        const doorTopLeft2 = doorBottomLeft2.clone().addScaledVector(vertical, doorHeight);
        const doorTopRight2 = doorBottomRight2.clone().addScaledVector(vertical, doorHeight);
        const doorVertices2 = new Float32Array([
          doorBottomLeft2.x, doorBottomLeft2.y, doorBottomLeft2.z,
          doorBottomRight2.x, doorBottomRight2.y, doorBottomRight2.z,
          doorTopRight2.x, doorTopRight2.y, doorTopRight2.z,
          doorTopLeft2.x, doorTopLeft2.y, doorTopLeft2.z
        ]);
        const doorGeom2 = new THREE.BufferGeometry();
        doorGeom2.setAttribute('position', new THREE.BufferAttribute(doorVertices2, 3));
        doorGeom2.setIndex([0, 1, 2, 2, 3, 0]);
        doorGeom2.computeVertexNormals();
        
        // Clean up existing door mesh
        if (doorMesh2) {
          scene.remove(doorMesh2);
          doorMesh2.geometry.dispose();
          doorMesh2.material.dispose();
        }
        
        const doorMaterial2 = new THREE.MeshBasicMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
        doorMesh2 = new THREE.Mesh(doorGeom2, doorMaterial2);
        scene.add(doorMesh2);
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Only update the scene if we're in panel view mode
        if (isViewingPanel) {
          updateScene();
        }
      }
      
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>